{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/corrsys/correctable.js","webpack:///./src/corrsys/index.js","webpack:///./src/corrsys/value.js","webpack:///./src/filtersys.js","webpack:///./src/index.js","webpack:///./src/mutableIcon.js","webpack:///./src/mutableMarker.js","webpack:///./src/utils/converter.js","webpack:///./src/utils/icons.js","webpack:///./src/utils/index.js","webpack:///./src/utils/misc.js","webpack:///./src/utils/options.js","webpack:///external {\"root\":\"L\",\"amd\":\"leaflet\",\"commonjs\":\"leaflet\",\"commonjs2\":\"leaflet\"}"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,gBAAgB,OAAO;AACvB,iBAAiB,GAAG;AACpB,iBAAiB,eAAe;AAChC;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,eAAe;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;;AAElC,sCAAsC,eAAe;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,eAAe;AACpC;AACA;AACA,qDAAqD;AACrD;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,gBAAgB,iDAAK;AACrB;AACA;;;AAGe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,IAAI;;AAEJ;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACpOD;AAAA;AAAA;AAA2C;AACW;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAM;AAChC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB,aAAa,aAAa;AAC1B;AACA;AACA,eAAe,mEAAW;AAC1B;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,C;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,mEAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,KAAK;AACzC;;AAEA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,8BAA8B,KAAK;;AAEnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,8BAA8B,KAAK;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,mB;;AAEA;AACA,8BAA8B,KAAK;;AAEnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEe,sEAAO,EAAC;;;;;;;;;;;;;ACjevB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,oEAAK,EAAC;;;;;;;;;;;;;ACxCrB;AAAA;AAAA;AACwC;;AAExC;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wBAAwB,EAAE;AACpD,+B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,oBAAoB,+CAA+C,EAAE;AACrE;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,sBAAsB;AACjC;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA,MAAM,8DAAM;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY;AACZ;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC,IAAI;AACJ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,wEAAS,EAAC;;;;;;;;;;;;;;AC1MzB;AAAA;AAAA;AAAA;AAA+C;AACJ;AAEwB;;AAEnE,mBAAmB,yDAAa;AAChC,iBAAiB,uDAAW;AAC5B;AACA,SAAS,oDAAI;AACb,2BAA2B,sEAAsB;AACjD,cAAc,yDAAS;AACvB,eAAe,0DAAU;AACzB,0BAA0B,qEAAqB;AAC/C;;AAEe,wHAAa,EAAC;;;;;;;;;;;;;;ACf7B;AAAA;AAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA,WAAW,+CAA+C;AAC1D;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,4DAAI;AACnB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,uDAAuD,uDAAO;;AAE9D;AACA;AACA;AACA,0CAA0C,mDAAmD,EAAE;AAC/F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,uCAAuC,qDAAqD,EAAE;AAC9F;;AAEA;AACA;AACA;AACA,IAAI;AACJ,CAAC,CAAC,EAAC;;;;;;;;;;;;;;ACnMH;AAAA;AAAA;AAAA;AAAqD;AACZ;AACF;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,4CAA4C,iBAAiB;AAC7D;AACe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2DAA2D;AAC3D,4BAA4B,yDAAO;AACnC;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,iDAAiD,qDAAS;AAC1D;AACA,6B;AACA;AACA,gD;AACA;AACA,UAAU;AACV;;AAEA;AACA,OAAO;AACP;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,6B;AACA;AACA,2CAA2C;AAC3C,6CAA6C;AAC7C;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,mDAAmD;AACnD,kDAAkD;AAClD;AACA;AACA,wCAAwC,gCAAgC;AACxE,qCAAqC,KAAK,IAAI,gCAAgC;AAC9E;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,yBAAyB;AACzB;AACA;AACA,gBAAgB,yDAAO;AACvB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA,mCAAmC,iCAAiC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAM;AACrB;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA,mBAAmB,OAAO;AAC1B;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,eAAe;AAChC;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,qDAAS;AACzB,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,yBAAyB,EAAE;AAC3D,6BAA6B,KAAK,IAAI,yBAAyB,EAAE;;AAEjE;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA,+CAA+C;;AAE/C,gDAAgD;AAChD;;AAEA;AACA,kCAAkC,yBAAyB,EAAE;AAC7D,+BAA+B,KAAK,IAAI,yBAAyB,EAAE;AACnE;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,mBAAmB,OAAO;AAC1B,iEAAiE;AACjE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,0BAA0B,4BAA4B,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,0CAA0C;AAC1C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa,mEAAW;AACxB,IAAI;AACJ;AACA;AACA,4DAA4D,qBAAqB;AACjF;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,mEAAW;AAC1B;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,aAAa,mEAAW,4BAA4B;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK;AACpC;AACA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,4BAA4B;AAC5B;AACA;AACA,uBAAuB,mEAAW;AAClC;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,aAAa,mEAAW,4BAA4B;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yBAAyB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yBAAyB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,EAAC;;;;;;;;;;;;;;ACpyBH;AAAA;AAAsC;;AAEtC;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA,YAAY,MAAM;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,QAAQ,uBAAuB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA,4DAA4D,4DAAW;AACvE;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,CAAC;;AAEc,wEAAS,EAAC;;;;;;;;;;;;;AC5RzB;AAAA;AAAA;AAAA;AAAA;AAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA,yBAAyB,+HAA+H;AACxJ;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,WAAW,iCAAiC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sBAAsB,uDAAW,SAAS,iBAAiB;AAC3D;AACA;AACA,+BAA+B,iBAAiB;AAChD;;AAEA;AACA;;;;;;;;;;;;;;ACzHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoD;AACiC;AAC/C;AACJ;;AAG4B;;;;;;;;;;;;;ACN9D;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB,EAAE;AACvD,+BAA+B,sBAAsB,EAAE;AACvD,IAAI;AACJ;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA,QAAQ,SAAS;AACjB;AACA,QAAQ;AACR;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,aAAa;AACb;AACO;AACP;AACA,yDAAyD;;AAEzD;AACA;;AAEA;;AAEA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9HA;AAAA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA,kBAAkB,KAAK;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,oBAAoB,iCAAiC,EAAE;AACvD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB,EAAE;AAC/C;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;;AAEc,sEAAO,EAAC;;;;;;;;;;;;;;;;;;;;;;;;AC5IvB,qD","file":"leaflet.mutatismutandis-debug.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"leaflet\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"leaflet\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"leaflet\")) : factory(root[\"L\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function(__WEBPACK_EXTERNAL_MODULE_leaflet__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import Value from \"./value.js\";\n\n/*\n * Convierte un array en un array con esteroides. Básicamente, el array\n * (llamémoslo *A*) pasa a tener un atributo *corr*, que es un objeto cuyas\n * claves son las correcciones aplicadas sobre *A* y cuyos valores son arrays de\n * longitud idéntica a *A*. Cada elemento de estos arrays represente el efecto\n * que ha tenido la corrección sobre el elemento correspondiente de *A*:\n *\n * - ``true``:  la correción filtró el elemento.\n * - ``false``: la corrección no filtró el elemento.\n * - ``undefined``: la corrección no se aplicó sobre ese elemento.\n * - ``null``: la corrección creó el elemento.\n *\n * Un ejemplo esquemático:\n *\n *            [ valor1   , valor2    , valor3]\n *  {\n *    corr1:  [ true     , true      , false ]\n *    corr2:  [ undefined, undefined ,  null ]\n *  }\n *\n * En este caso, el *valor1* lo eliminan ambas correcciones. el *valor2*\n * sólo *corr1*, y el *valor3* lo añade *corr2* y no lo elimina *corr1*.\n *\n */\n\n/**\n * @name Correctable\n * @hideconstructor\n * @class\n * @classdesc La clase permite apuntar sobre el array qué elementos han sido filtrados\n * por cuáles correcciones y qué nuevos elementos han sido añadidos y por cuál corrección.\n * @param {Array} arr El array original.\n * @param {Object} sc Parte del :js:class:`sistema de correcciones <CorrSys>` que se aplica\n * exclusivamente al array.\n */\nconst Prototype = {\n   /**\n    * Devuelve las correcciones que han eliminado el elemento idx del array.\n    *\n    * @param {int} idx Índice del elemento que se quiere consultar.\n    * @returns {Array} Array con los nombres\n    */\n   filters: function(idx) {\n      return Object.keys(this.corr).filter(n => this.corr[n][idx])\n                                   .map(c => this._sc.getOriginal(c));\n   },\n   /**\n    * @typedef {Object} Correctable.CorrValue\n    * @property {?*} value   El valor del elemento o ``null``, si alguna corrección lo eliminó.\n    * @property {Array.<String>} filters  Los nombres de las correcciones que eliminan el elemento.\n    */\n\n   /**\n    * Aplica una determinada corrección sobre el array.\n    *\n    * @param {Marker} marker  Marca a la que pertenece el :class:`Correctable`\n    * @param {String} name    El nombre de la corrección.\n    *\n    * @returns {boolean}  ``true`` Si la correción\n    *    provocó algún cambio en el array.\n    */\n   apply: function(marker, name) {\n      const opts = this._sc.getOptions(name);\n\n      if(opts.add) {\n         // La corrección ya estaba aplicada: la desaplicamos.\n         if(this.corr.hasOwnProperty(name)) this.unapply(name);\n\n         const values = opts.func.call(marker, null, this, opts.params);\n         let num = values.length;\n         if(num === 0) return false;\n         Array.prototype.push.apply(Object.getPrototypeOf(this), values);\n\n         this.corr[name] = new Array(this.length);\n         for(let i=this.length-num; i<this.length; i++) this.corr[name][i] = null;\n         this._count = undefined;\n\n         // Las correcciones que eliminan valores,\n         // pueden eliminar los valores añadidos.\n         for(const n in this.corr) {\n            const opts = this._sc.getOptions(n);\n\n            this.corr[n].length = this.length;\n            if(opts.add) continue;  // Es una corrección que añade valores.\n\n            for(let i=this.length-num; i<this.length; i++) {\n               this.corr[n][i] = opts.func.call(marker, i, this, opts.params);\n            }\n         }\n\n         return true;\n      }\n      else {\n         let ret = false;\n         if(!this.corr.hasOwnProperty(name)) this.corr[name] = new Array(this.length);\n\n         for(let i=0; i<this.length; i++) {\n            const prev = this.corr[name][i];\n            this.corr[name][i] = opts.func.call(marker, i, this, opts.params);\n            if(prev ^ this.corr[name][i]) ret = true;  // La corrección cambia sus efectos.\n         }\n\n         if(ret) this._count = undefined;\n         return ret;\n      }\n   },\n   /**\n    * Deshace una determinada corrección hecha previamente.\n    *\n    * @param {String} name Nombre de la corrección.\n    *\n    * @returns {Boolean}  ``true`` si eliminar la corrección\n    *    provocó cambios en el *array*.\n    */\n   unapply: function(name) {\n      const opts = this._sc.getOptions(name);\n\n      if(opts.add) {\n         if(!this.corr.hasOwnProperty(name)) return false; // No se había aplicado.\n         const arr = this.corr[name];\n         delete this.corr[name];\n         let a, b;\n         for(let i=0; i<arr.length; i++) {\n            if(arr[i] === null) {\n               if(a === undefined) a=i;\n            }\n            else if(a !== undefined) {\n               b=i;\n               break;\n            }\n         }\n         if(a === undefined) return false;\n         if(b === undefined) b = arr.length;\n         this._count = undefined;\n         // Eliminamos los valores al array añadidos por esta corrección\n         Object.getPrototypeOf(this).splice(a, b-a);\n         for(const name in this.corr) this.corr[name].splice(a, b-a);\n      }\n      else {\n         if(!this.corr.hasOwnProperty(name)) return false; // No se había aplicado.\n         const arr = this.corr[name];\n         delete this.corr[name];\n         if(arr.some(e => e)) this._count = undefined;\n         else return false;\n      }\n\n      return true;\n   },\n   /**\n    * Limpia el array de todas las correcciones.\n    */\n   clear: function() {\n      // Primer elemento que tiene un null (o sea, no formaba parte del array original.\n      const idx = Math.min.apply(null, Object.keys(this.corr).map(k => this.corr[k].indexOf(null)).filter(e => e >= 0));\n      this.length = idx;\n      for(const name in Object.getOwnPropertyNames(this.corr)) delete this.corr[name];\n   }\n}\n\n\n// Total de elementos excluyendo los eliminados por correcciones.\nfunction total() {\n   if(this._count !== undefined) return this._count;\n   this._count = 0;\n   for(let i=0; i<this.length; i++) {\n      if(this.filters(i).length === 0) this._count++;\n   }\n   return this._count;\n}\n\n\n/**\n * Iterador que genera un objeto Value para cada elemento del array\n * a fin de que se pueda saber si el valor está o no filtrado.\n * @generator\n */\nfunction* iterator() {\n   for(let i=0; i<this.length; i++) {\n      yield new Value(this[i], this.filters(i));\n   }\n}\n\n\nexport default function(arr, sc) {\n   if(!(arr instanceof Array)) throw new TypeError(\"El objeto no es un array\");\n   const obj = Object.assign(Object.create(arr), Prototype);\n   Object.defineProperties(obj, {\n      \"_sc\": {\n         value: sc,\n         writable: false,\n         enumerable: false,\n         configurable: false\n      },\n      /**\n       * Objeto que almacena las correcciones del array.\n       * Cada clave es el nombre de la corrección y cada valor\n       * un array \n       */\n      \"corr\": {\n         value: {},\n         writable: false,\n         enumerable: false,\n         configurable: false,\n      },\n      // Pre-almacena el número de elementos para mejorar el rendimiento.\n      \"_count\": {\n         value: arr.length,\n         writable: true,\n         configurable: false,\n         enumerable: false\n      },\n      /**\n       * Longitud del array corregido, descontados los valores anulados.\n       * @name Correctable#total\n       * @type {Number}\n       */\n      \"total\": {\n         get: total,\n         enumerable: false,\n         configurable: false\n      },\n   });\n\n   obj[Symbol.iterator] = iterator;\n\n   return obj;\n}\n","import Correctable from \"./correctable.js\";\nimport {getProperty, equals} from \"../utils/index.js\";\n\n/**\n * @name CorrSys\n * @class\n * @hideconstructor\n * @classdesc Implemeta un sistema para realizar correcciones sobre los atributos\n * *array* de un objeto. Las correcciones consisten bien en filtrar sus elementos,\n * bien en añadir nuevos.\n *\n * El sistema de correcciones estará constituido por varias correcciones, cada una\n * de las cuales tiene un nombre y afectará a un atributo del objeto.\n * Varias correcciones podrán afectar a un mismo atributo, pero una\n * corrección no podrá afectar a varios atributos.\n *\n * Puede ocurrir también que la aplicación de una corrección desencadene\n * automáticamente la aplicación de una o más correcciones que afectan a otros\n * atributos. En este caso, si la corrección que se aplica es \"bilingue\" y la\n * corrección que se desencadena automáticamente es \"adjpue\", la corrección\n * automática se identificará como \"bilingue adjpue\".\n * \n * Las :js:class:`clases de marcas definidas como mutables <Marker>` definen\n * automáticamente una opción ``corr`` que es un objeto de este tipo, de modo\n * que cuando se usan métodos que definen o aplican correcciones obre las marcas\n * de la clase (:js:meth:`Marker.register`, :js:meth:`Marker.correct`,\n * :js:meth:`Marker.uncorrect`) se utiliza este objeto.`\n *\n */\nfunction CorrSys() {}\n\n/**\n * Registra una corrección.\n * @method CorrSys#register\n *\n * @param {String} name Nombre de la corrección\n * @param {Object} obj  Objeto que define la corrección. :js:meth:`Marker.register` \n * para saber cómo es este objeto.\n * @param {Array} chain  Correcciones que se aplicarán automáticamente\n * tras la aplicación de esta corrección. Cada elemento es un objeto con dos atributos,\n * el nombre de la corrección que se desencadena (``corr``) y la función que\n * transforma las opciones de la corrección aplicada en opciones de la corrección\n * desencadena. Si la aplicación concreta de la corrección no debe provocar el\n * desencadenamiento de la segunda corrección, debe devolverse ``false``.\n *\n * @returns {CorrSys} El propio objeto\n */\nCorrSys.prototype.register = function(name, obj) {\n   // Internamente el objeto tiene la forma\n   // {\n   //   prop1: {\n   //             corr1: func1,\n   //             corr2: func2\n   //          },\n   //   prop2: {\n   //             corr3: func3\n   //          }\n   // }\n   //\n   // propX son los nombres de las propiedades de los datos. Si la propiedad\n   // está anidada se usa la notación del punto.\n   // corrX es el nombre de la corrección.\n   // funcX: Es la función de corrección a la que se le añaden algunas características.\n   //       - nombre.\n   //       - si es aditiva.\n   //       - con qué parámetros se ha aplicado.\n   //       - la cadena de correcciones.\n   const sc = this[obj.attr] = this[obj.attr] || {};\n   if(sc.hasOwnProperty(name)) {\n      console.warn(`${name}: La corrección ya está registrada`);\n      return false;\n   }\n   // Apuntamos en una propiedad de la función, el nombre de la corrección,\n   // si es aditiva, y con qué opciones se ha aplicado.\n   obj.func.prop = {\n      name: name,\n      add: obj.add,\n      apply: obj.apply || equals,  // Issue #58\n      default_auto: obj.autochain || false,  // Issue #39\n      params: null,  // Issue #23.\n      // Issue #37\n      chain: obj.chain || [],  // Correcciones que aplica automáticamente esta corrección\n      chain_params: {}  // key: eslabones previos de la cadena de correcciones.\n                        // value: las opciones de corrección\n      // Fin issue # 37\n   }\n   sc[name] = obj.func;\n   return this;\n}\n\n// Issue #58\n/** \n * Comprueba si las opciones de aplicación suministradas son inútiles,\n * porque ya hay al menos otra aplicación de la corrección que abarca\n * tales opciones.\n *\n * @param {String} name Nombre de la corrección.\n * @param {Object} params Opciones de aplicación.\n * @param {Object} type Tipo de comprobación que puede ser \"*manual*\",\n * si sólo se pretende consultar la anterior aplicación manual de la\n * corrección, \"*auto*\", si sólo se pretenden consultar las aplicaciones\n * automáticas de la corrección; y cualquier otro valor para consultar\n * todas.\n */\nCorrSys.prototype.isApplied = function(name, params, type) {\n   const opts = this.getOptions(name);\n         \n   let a_params = [] \n\n   if(type !== \"auto\" && opts.params) a_params.push(opts.params);\n   if(type !== \"manual\") {\n      let params = this.getAutoParams(name);\n      params = Object.keys(params).map(c => params[c]);\n      a_params.push.apply(a_params, params);\n   }\n\n   for(const oldparams of a_params) {\n      if(opts.apply(oldparams, params)) return true;\n   }\n   return false;\n}\n// Fin issue #58\n\n// Issue #37\n/**\n * Normaliza el nombre. Las correcciones encadenadas forman su nombre\n * encadenando todos los eslabones de la cadena y separándolos por espacio.\n * Por ejemplo, \"*bilingue adjpue*\" es la corrección *adjpue* que aplica\n * automáticamente otra corrección llamda bilingue. En este ejemplo,\n * el nombre normalizado es \"*adjpue*\" y el prenombre \"*bilingue*\"\n * @method CorrSys#_normalizeName\n * @private\n *\n * @param {String} name El nombre que se quiere normalizar,\n * @param {Boolean} prename Si se quiere obtener también el prenombre.\n *\n * @returns {String|Array.<String>}  El nombre normalizado o un array\n * con el nombre normalizado y el prenombre si el argumento ``prename`` era\n * ``true``.\n */\nCorrSys.prototype._normalizeName = function(name, prename) {\n   const lastSpace = name.lastIndexOf(\" \");\n   if(lastSpace === -1) return prename?[\"\", name]:name;\n   else {\n      const res = name.substring(lastSpace+1);\n      return prename?[name.substring(0, lastSpace), res]:res;\n   }\n}\n// Fin #issue 37\n\n/**\n * Informa de si la propiedad de una marca es corregible.\n * @method CorrSys.prototype.isCorrectable\n *\n * @param {String} attr     Nombre de la propiedad que se quiere investigar. Es admisible\n *    la notación de punto para propiedades anidadas.\n * @param {Marker} marker Marca donde se encuentra la propiedad\n * @returns {?Correctable}   La propia propiedad si es corregible, o nulo.\n */\nCorrSys.prototype.isCorrectable = function(attr, marker) {\n   const arr = getProperty(marker.getData(), attr);\n   if(arr && arr.correctable) return arr.correctable;\n   else null;\n}\n\n\n/**\n * Devuelve las correcciones aplicables a una propiedad.\n * @method CorrSys#getCorrections\n *\n * @param {?String} attr  Nombre de la propiedad. Si es ``null``, devolverá\n * los nombres de todas las correcciones.\n *\n * @returns {?Object.<String, Function>}  Un objeto en que cada atributo es el nombre\n * de las corrección y cada valor la función que la define.\n */\nCorrSys.prototype.getCorrections = function(attr) {\n   if(attr) return this[attr] || null;\n   else {\n      const res = {};\n      for(const attr in this) Object.assign(res, this[attr]);\n      return res;\n   }\n}\n\n/**\n * Devuelve el nombre de todas las correcciones aplicadas\n * manualmente y las opciones con las que se aplican.\n *\n * @returns {Object} Un objeto cuyas claves son los nombres\n * de las correcciones aplicadas y cuyos valores son las opciones.\n */\nCorrSys.prototype.getAppliedCorrections = function() {\n   const ret = {},\n         corrs = this.getCorrections();\n\n   for(const name in corrs) {\n      const opts = corrs[name].prop;\n      if(!opts.params) continue;\n      ret[name] = opts;\n   }\n\n   return ret;\n}\n\n/**\n * Devuelve las propiedades corregibles.\n * @method CorrSys#list\n *\n * @returns {Array.<String>}\n */\nCorrSys.prototype.list = function() {\n   return Object.keys(this);\n} \n\n/**\n * Prepara un objeto convirtiendo los arrays en Correctables.\n * @method CorrSys#prepare\n *\n * @param {Object} obj  El objeto que sufrirá el cambio.\n * @param {String} prop Un array concreto del objeto que se quiere convertir\n *    en Correctable. Si no se especifica, se buscan todos para los\n *    que se hayan definido al menos una corrección.\n */\nCorrSys.prototype.prepare = function(obj, prop) {\n   const attrs = (prop === undefined)?this.list():[prop];\n   for(let attr of attrs) {\n      let o, name;\n      const idx = attr.lastIndexOf(\".\");\n\n      if(idx === -1) {\n         o = obj;\n         name = attr;\n      }\n      else {\n         o = getProperty(obj, attr.substring(0, idx));\n         if(o === undefined) {\n            console.error(\"El objeto carece de la propiedad \" + attr.substring(0, idx));\n            continue\n         }\n         name = attr.substring(idx+1);\n      }\n      // Consideraremos que si falta el atributo, es un array vacío)\n      if(o[name] === undefined) o[name] = [];\n      if(!(o[name] instanceof Array)) {\n         console.error(\"La propiedad no es un Array\");\n         continue\n      }\n      const correctable = new Correctable(o[name], this);\n      // Issue #B.2\n      Object.defineProperty(o, name, {\n         get: () => {\n            const ret = Array.from(correctable).filter(e => e.filters.length === 0)\n                                               .map(e => e.isPrimitive()?e.value:e);\n            ret.correctable = correctable;\n            return ret;\n         }\n      });\n      // Fin #B.2\n   }\n}\n\n/**\n * Devuelve la propiedad de los datos que corrige la corrección.\n * @method CorrSys#getProp\n *\n * @param {string} name  Nombre de la corrección\n *\n * @returns {string} El nombre de la propiedad en notación de punto.\n */\nCorrSys.prototype.getProp = function(name) {\n   name = this._normalizeName(name);\n   for(const prop in this) {\n      if(this[prop].hasOwnProperty(name)) return prop;\n   }\n}\n\n/**\n * @typedef {Object} CorrSys.OptionsCorr\n * @property {?String}  prename  Eslabones previos de la cadena de correcciones.\n * @property {String}   name     Nombre de la corrección (sin eslabones previos).\n * @property {Boolean}  add      true, si la corrección agrega valores.\n * @property {Object}   params   Opciones de aplicación de la corrección.\n * @property {Array}    chain    Array con las correcciones que desenacadena\n * @property {String}   attr     El nombre de la propiedad sobre la que actúa la corrección.\n * @property {Function} func     La función de corrección.\n * automáticamente la corrección.\n */\n\n// Issue #23 - Modificado por issue #37.\n/**\n * Devuelve las características de una corrección\n * @method CorrSys.prototype.getOptions\n *\n * @param {String} name  Nombre de la corrección.\n *\n * @returns {OptionsCorr}\n */\nCorrSys.prototype.getOptions = function(name) {\n   let ret, prename;\n   [prename, name] = this._normalizeName(name, true);\n\n   const property = this.getProp(name);\n   if(!property) throw new Error(`${name}: corrección no registrada`);\n   const sc = this[property];\n\n   ret = {attr: property, func: sc[name]}\n   Object.assign(ret, ret.func.prop);\n\n   if(prename) {\n      ret.params = ret.chain_params[prename];\n      ret.prename = prename;\n   }\n   delete ret.chain_params;\n\n   return ret;\n}\n\n/**\n * Establece unas nuevas opciones de aplicación de una determinada corrección.\n * @method CorrSys#setParams\n *\n * @params {String} name   Nombre de la corrección.\n * @params {Object} opts   Opciones de aplicación de la corrección.\n *\n * @returns {Object}   Las propias opciones.\n */\nCorrSys.prototype.setParams = function(name, opts) {\n   const sc = this[this.getProp(name)];\n   if(!sc) throw new Error(`${name}: corrección no registrada`);\n\n   let [prename, postname] = this._normalizeName(name, true);\n\n   if(prename) {\n      if(opts !== null) sc[postname].prop.chain_params[prename] = opts;\n      else delete sc[postname].prop.chain_params[prename];\n   }\n   else sc[name].prop.params = opts;\n\n   // Si se borran los opciones de corrección (se fijan a null), se deben\n   // borrar recursivamente las opciones calculadas del resto de la cadena.\n   // Issue #60: o si se fijan unas nuevas opciones manuales, resetear las calculadas.\n   if(opts === null || !prename) {\n      for(const chain of sc[postname].prop.chain) {\n         if(this.looped(name, chain.corr)) continue;\n         this.setParams(postname + \" \" + chain.corr, null);\n      }\n   }\n\n   return opts;\n}\n// Fin issue #23\n\n/**\n * Resetea el objeto.\n *\n * @param {Boolean} deep  Si ``true``, elimina del sistema las correcciones;\n *    de lo contrario, sólo las marca como desaplicadas.\n */\nCorrSys.prototype.reset = function(deep) {\n   if(deep) for(const prop in this) delete this[prop];\n   else {\n      const corrs = this.getCorrections();\n      for(const name in corrs) this.setParams(name, null);\n   }\n   return this;\n}\n\n\n/**\n * Inicializa la corrección, fijando las opciones y si se deben\n * aplicar automáticamente las correcciones definidas en su cadena.\n * @params {String} name  El nombre de la corrección.\n * @params {Object} opts  Opciones de corrección.\n * @params {Boolean} auto Si ``true``, se aplicaráb las correciones de la cadena.\n *\n * @returns {CorrSys} El propio objeto.\n */\nCorrSys.prototype.initialize = function(name, opts, auto) {\n   this.setParams(name, opts);\n   const sc = this[this.getProp(name)];\n   try {\n      sc[name].prop.auto = sc[name].prop.default_auto;  // Issue #39\n      if(auto !== undefined) sc[name].prop.auto = !!auto;\n   }\n   catch(error) {\n      console.warn(\"¿Está intentando inicializar una corrección encadenada?\");\n      throw error;\n   }\n\n   return this;\n}\n\n/**\n * Comprueba si la cadena forma un bucle\n *\n * @param {String}  chain  Los nombres de las correcciones que forman la cadena.\n * @oaram {?String} name   La nueva corrección que se desea añadir a la cadena.\n * Si no se define, se entenderá que *chain* ya lo incorpora.\n *\n * @returns {Boolean} ``true``, si se forma bucle.\n */\nCorrSys.prototype.looped = function(chain, name) {\n   chain = chain.split(\" \");\n   if(!name) name = chain.pop();\n\n   return chain.indexOf(name) !== -1;\n}\n\n/**\n * Devuelve todos las opciones con las que se ha aplicado automáticamente\n * una corrección.\n * \n * @param {String} name  El nombre de la corrección.\n *\n * @returns {Object}  Un objeto en que las claves son las correcciones originales\n * que provocaron las correcciones y los valores las opciones de corrección.\n */\nCorrSys.prototype.getAutoParams = function(name) {\n   const sc = this[this.getProp(name)];\n   if(!sc) throw new Error(`${name}: corrección no registrada`);\n\n   name = this._normalizeName(name);\n   const params = sc[name].prop.chain_params;\n\n   let res = {};\n   for(const n in params) {\n      res[this.getOriginal(n)] = params[n];\n   }\n   return res;\n}\n\n/**\n * Devuelve la correccion original que desencadenó\n * la corrección que se consulta.\n *\n * @param {String} name  El nombre de la corrección.\n *\n * @returns {String} La corrección que originariamente\n * desencadenó la corrección suministrada.\n */\nCorrSys.prototype.getOriginal = function(name) {\n   const idx = name.indexOf(\" \");\n   return idx === -1?name:name.substring(0, idx);\n}\n// Fin issue #37\n\n/**\n * Devuelve todas las correcciones que ha desencadenado\n * automáticamente la corrección suministrada y cuáles\n * han sido los parámetros con los que se ha desencadenado.\n * Se incluye a sí misma.\n *\n * @param {String} name  El nombre de la corrección desencadenante.\n *\n * @returns {Object} Objeto en que cada clave es una de las\n * correcciones desencadenadas y el valor, los parámetros con los\n * que se aplicó.\n */\nCorrSys.prototype.getAutoCorrs = function(name, ret) {\n   ret = ret || {}; \n\n   const sc = this[this.getProp(name)];\n   if(!sc) throw new Error(`${name}: corrección no registrada`);\n\n   let [prename, postname] = this._normalizeName(name, true);\n\n   if(prename) {\n      const opts = sc[postname].prop.chain_params[prename];\n      if(opts) ret[postname] = opts;\n   }\n   else ret[name] = sc[name].prop.params;\n\n   for(const chain of sc[postname].prop.chain) {\n      if(this.looped(name, chain.corr)) continue;\n      this.getAutoCorrs(name + \" \" + chain.corr, ret);\n   }\n\n   return ret;\n}\n\nexport default CorrSys;\n","/**\n * @name Value\n * @hideconstructor\n * @class\n * @classdesc Genera un valor que permite conocer si está filtrado o no.\n * Si el valor es un objeto, simplemente, devuelve otro que añade la propiedad\n * ``filters`` que contiene en un Array los nombres de las correcciones que han filtrado el valor.\n * Si el valor es un tipo primitivo, genera un objeto que almacena en la propiedad ``value`` el\n * valor original y en ``filters`` la lista de correcciones que lo filtran.\n */\nfunction Value(value, filters) {\n   Object.defineProperty(this, \"__primitive\", {\n      value: typeof value !== \"object\" || value === null,\n      writable: false,\n      configurable: false,\n      enumerable: false\n   });\n   if(this.isPrimitive()) this.value = value;\n   else {\n      if(value.filters !== undefined) console.warn(\"El valor original del array posee un atributo filters y se perderá\");\n      Object.assign(this, value);\n   }\n   Object.defineProperty(this, \"filters\", {\n      value: filters,\n      writable: false,\n      configurable: false,\n      enumerable: false\n   });\n}\n\nValue.prototype.isPrimitive = function() { return this.__primitive };\nValue.prototype.valueOf = function() {\n   if(this.isPrimitive()) return this.value;\n   else return this;\n}\nValue.prototype.toString = function() {\n   if(this.isPrimitive()) return this.value.toString();\n   else return Object.prototype.toString.call(this);\n}\n\nexport default Value;\n","// Issue #5\nimport {equals} from \"./utils/index.js\";\n\n/**\n * Construye un sistema de filtros\n * @name FilterSys\n * @class\n * @param {Function|L.LayerGroup|string} style  Estilo de filtrado.\n * Consulte la opción ``filter`` de las :js:attr:`optiones de Marker <Marker.options>`\n * para conocer cuáles son sus valores posibles.\n * @classdesc Implementa un sistema de filtros para las marcas.\n * Las :js:class:`clases de marcas definidas como mutables <Marker>` definen\n * una propiedad ``filter`` que es un objeto de este tipo, de modo que los métodos\n * que definen o aplican filtros a las marcas de la clase (:js:meth:`Marker.registerF`,\n * :js:meth:`Marker.filter`, :js:meth:`Marker.unfilter`),\n * utilizan este objeto.\n */\nfunction FilterSys(style) {\n   Object.defineProperties(this, {\n      transform: {\n         get: function() { return this._transform; },\n         set: function(value) { \n            if(this.hideable) this.transform.off(\"layeradd\", this.ejectFiltered);\n            if(typeof value === \"string\") {\n               this._transform = function(filtered) {\n                  if(filtered) this.classList.add(value);\n                  else this.classList.remove(value);\n               }\n            }\n            else {\n               this._transform = value; \n               if(this.hideable) this.transform.on(\"layeradd\", this.ejectFiltered);\n            }\n         },\n         configurable: false,\n         enumerable: false\n      },\n      _transform: {\n         writable: true,\n         enumerable: false,\n         configurable: false\n      }\n   });\n   this.transform = style;\n}\n\n/**\n * Informa de si la marca debe ocultarse.\n * @name FilterSys#hideable\n * @type {Boolean}\n */\nObject.defineProperty(FilterSys.prototype, \"hideable\", {\n   get: function() { return this.transform instanceof L.LayerGroup; },\n   configurable: false,\n   enumerable: false\n});\n\n/**\n * Expulsa automáticamente de la capa las marcas filtradas.\n * @method FilterSys#ejectFiltered\n */\nFilterSys.prototype.ejectFiltered = e => e.layer.refresh();\n\n/**\n * Registra una corrección\n * @memberof FilterSys\n *\n * @param {String}  name  Nombre del filtro.\n * @param {Object}  obj   Propiedades del filtro.\n * @param {String|Array.<String>} obj.attrs Nombre de las propiedades de los datos\n * cuyos valores afecta al filtro.\n * @param {Function} obj.func  Función que filtra. Debe devolver\n * ``true`` (sí filtra) o ``false``.\n */\nFilterSys.prototype.register = function(name, obj) {\n   if(this[name]) {\n      console.warn(`${name}: El filtro ya está registrado`);\n      return false;\n   }\n   if(!(obj.attrs instanceof Array)) obj.attrs = [obj.attrs];\n   obj.func.prop = {\n      depends: obj.attrs,\n      enabled: false,\n      params: undefined\n   }\n   this[name] = obj.func;\n   return this;\n}\n\n/**\n * Devuelve los filtros habilitados cuyo resultados dependen de\n * la propiedad cuyo nombre se suministra\n * @memberof FilterSys\n *\n * @param {?String} attr Nombre de la propiedad. Si no se facilita, devuelve\n *    todos los filtros habilitados.\n *\n * @retuns  {Array.<string>}   Los nombres de los filtros.\n */\nFilterSys.prototype.getFilters = function(attr) {\n   return Object.keys(this).filter(filter => \n      this[filter].prop.enabled\n   && (\n         !attr\n         || this[filter].prop.depends.indexOf(attr) !== -1\n      )\n   );\n}\n\n/**\n * Habilita un filtro\n * @memberof FilterSys\n *\n * @param {String} name  El nombre del filtro que se quiere habilitar.\n */\nFilterSys.prototype.enable = function(name) {\n   if(!this.hasOwnProperty(name) || this[name].prop.enabled) return false;\n   this[name].prop.enabled = true;\n   return this;\n}\n\n/**\n * Deshabilita un filtro\n * @memberof FilterSys\n *\n * @param {string} name  El nombre del filtro que se quiere deshabilitar.\n */\nFilterSys.prototype.disable = function(name) {\n   if(!this.hasOwnProperty(name) || !this[name].prop.enabled) return false;\n   this[name].prop.enabled = false;\n   this[name].prop.params = undefined;\n   return this;\n}\n\n/**\n * Establece unas nuevas opciones de aplicación para el filtro.\n * @memberof FilterSys\n *\n * @params {String} name   Nombre del filtro.\n * @params {Object} opts   Opciones de aplicación del filtro.\n * @params {Boolean} enable   Fuerza a habilitar el filtro.\n *\n * @returns {(Boolean|FilterSys)} <code>false</code> en caso de que el filtro\n *    no exista, esté deshabilitado, o estuviera habilitado, pero con\n *    las mismas opciones.\n */\nFilterSys.prototype.setParams = function(name, opts, enable) {\n   if(!this.hasOwnProperty(name)) return false;\n   if(!enable && !this[name].prop.enabled) return false;  // No se fuerza la habilitación y no está habilitado.\n   else this[name].prop.enabled = true;\n   if(equals(this[name].prop.params, opts)) return false;\n   this[name].prop.params = opts;\n   return this;\n}\n\n/**\n * Obtiene las opciones de filtrado de un determinado filtro.\n * @memberof FilterSys\n *\n * @param {string} name    El nombre del filtro.\n *\n * @return {Object}\n */\nFilterSys.prototype.getParams = function(name) {\n   if(!this.hasOwnProperty(name)) throw new Error(`${name}: filtro no registrado`);\n   return this[name].prop.params;\n}\n\n/**\n * Modifica el estilo de filtrado.\n * @memberof FilterSys\n *\n * @param {Function|L.LayerGroup|String} style  Estilo de filtrado. Consulte el\n * {@link Marker#options valor de la opción filter para Marker.prototype.options}\n * @param {Marker} markerClass    Clase de marca a la que pertenecen\n *    todas las marcas que usan este objeto de filtrado.\n */\nFilterSys.prototype.setStyle = function(style, markerClass) {\n   const old = this.transform,\n         exhideable = old instanceof L.LayerGroup;\n   this.transform = style;\n\n   // Si el estilo anterior ocultaba las marcas y el nuevo no lo hace,\n   // las marcas filtradas deben añadirse a la capa y ésta debe pasarse\n   // a refresh como parámetro.\n   markerClass.invoke(\"refresh\", null, exhideable && !this.hideable && old);\n}\n\n// Issue #40\n/**\n * Resetea el objeto.\n *\n * @param {Boolean} deep  Si ``true``, elimina del sistema los filtros;\n * de lo contrario, sólo los marca como desaplicados.\n */\nFilterSys.prototype.reset = function(deep) {\n   if(deep) for(const name in this) delete this[name];\n   else for(const name in this) this.disable(name);\n   return this;\n}\n// Fin issue #40\n\nexport default FilterSys;\n","import MutableMarker from \"./mutableMarker.js\";\nimport MutableIcon from \"./mutableIcon.js\";\nimport {load, createMutableIconClass, Converter,\n        grayFilter, noFilteredIconCluster} from \"./utils/index.js\";\n\nL.Marker.Mutable = MutableMarker;\nL.Icon.Mutable = MutableIcon;\nL.utils = {\n   load: load,\n   createMutableIconClass: createMutableIconClass,\n   Converter: Converter,\n   grayFilter: grayFilter,\n   noFilteredIconCluster: noFilteredIconCluster\n}\n\nexport default MutableMarker;\n","import {Options, load} from \"./utils/index.js\";\n\n/**\n * Genera un `HTMLElement\n * <https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement>`_ a partir del\n * parámetro que se le proporciona.\n * \n * @param {(HTMLElement|Document|DocumentFragment|String)} Definición del elemento.\n *\n * @returns {HTMLElement} El elemento generado.\n */\nfunction getElement(e) {\n   if(typeof e === \"string\" || e instanceof String) {\n      const div = document.createElement(\"div\");\n      div.innerHTML = e;\n      e = document.createDocumentFragment();\n      Array.from(div.children).forEach(node => e.appendChild(node));\n   }\n\n   if(e instanceof Document || e instanceof DocumentFragment) {\n      if(e.children.length === 1) {\n         e = e.firstElementChild.cloneNode(true);\n         e.container = false;\n      }\n      else {\n         const container = document.createElement(\"div\");\n         for(const x of e.children) container.appendChild(x.cloneNode(true));\n         e = container;\n         e.container = true;\n      }\n   }\n   else if(e instanceof HTMLElement) {\n      e = e.cloneNode(true);\n      e.container = false;\n   }\n   else throw new TypeError(\"Tipo de elemento no soportado\");\n   return e;\n}\n\n\n/**\n * @name L.Icon.Mutable\n * @extends L.DivIcon\n * @classdesc Extensión de `L.DivIcon <https://leafletjs.com/reference-1.4.0.html#divicon>`_\n * a fin de crear iconos definidos por una plantilla a la que se aplican\n * cambios en sus detalles según sean cambien los valores de sus opciones de\n * dibujo. Consulte :js:attr:`Icon.options` para conocer cuales son las\n * opciones adicionales que debe proporcionar para que la clase sea capaz de\n * manejar iconos mutables.\n *\n * .. warning:: Para crear el icono, use preferente la función :js:func:`L.utils.createMutableIconClass`.\n *\n * @class\n * @hideconstructor\n *\n * @example\n * function updater(o) {\n *    const content = this.querySelector(\".content\");\n *    if(o.hasOwnProperty(tipo) content.className = \"content \" + o.tipo;\n *    if(o.hasOwnProperty(numadj) content.textContent = o.numadj;\n *    return this;\n * }\n *\n * const Icon = L.Icon.Mutable.extend({\n *    options: {\n *       className: \"icon\",\n *       iconSize: [25, 34],\n *       iconAnchor: [12.5, 34],\n *       url: \"images/boliche.svg\",\n *       updater: updater,\n *       converter: new L.utils.Converter([\"numadj\", \"tipo\"])\n *                             .define(\"numadj\", \"adj\", a => a.total)\n *                             .define(\"tipo\")\n *    }\n * });\n *\n * const icon = new Icon();\n */\nexport default L.DivIcon.extend({\n   /** @lends L.Icon.Mutable.prototype */\n   // Issue #2\n   statics: {\n      /** @lends L.Icon.Mutable */\n\n      /**\n       * Informa si la clase de icono se encuentra lista para utilizarse.\n       * @type {Boolean}\n       */\n      isready() {\n         return !!this.prototype.options.html;\n      },\n      /**\n       * Define qué hacer cuando la clase de icono esté lista para usarse.\n       * @async\n       *\n       * @param {Function} success  Define la acción que se realizará en caso\n       * de que la creación de la clase de icono haya tenido éxito.\n       * @param {Function} fail Define la acción a realizar en caso de que\n       * la creación del icono haya fallado.\n       */\n      onready: function(func_success, func_fail) {\n         if(!this.isready()) {\n            if(this._onprocess) {  // Ya está pedido el fichero, así que esperamos.\n               const id = setInterval(() => {\n                  if(this.isready()) {\n                     clearInterval(id);\n                     delete this._onprocess;\n                     func_success();\n                  }\n               }, 20);\n            }\n            else {\n               this._onprocess = true;\n               load({\n                  url: this.prototype.options.url,\n                  callback: xhr => {\n                     this.prototype.options.html = getElement(xhr.responseXML);\n                     delete this._onprocess;\n                     func_success();\n                  },\n                  failback: xhr => {\n                     delete this._onprocess;\n                     func_fail(xhr.statusText);\n                  }\n               });\n            }\n         }\n         else func_success();\n         return this;\n      },\n      // Para comprobar que se incluyeron updater y converter\n      extend: function(obj) {\n         const MutableIcon = L.Icon.extend.call(this, obj);\n         const options = MutableIcon.prototype.options;\n         if(options.updater && options.converter) {\n            if(options.html) options.html = getElement(options.html);\n            else if(!options.url) throw new Error(\"Falta definir las opciones html o url\");\n         }\n         else throw new Error(\"Un icono mutable requiere funciones updater y converter\");\n         return MutableIcon;\n      }\n   },\n   // Fin issue #2\n   /**\n    * Wrapper para el método homónimo de `L.DivIcon\n    * <https://leafletjs.com/reference-1.4.0.html#divicon>`_. Su función\n    * es preparar el valor ``options.html`` usando la plantilla y \n    * las opciones de dibujo antes de que el método original actúe.\n    * \n    *\n    * @returns {HTMLElement}\n    */\n   createIcon: function() {\n      this.options.params = this.options.params || new Options(this.options.converter.run(this._marker.getData()));\n\n      // Las opciones de dibujo cambiaron mientras el icono no estaba presente en el mapa.\n      if(!this.options.params.updated) {\n         delete this.options.html;\n         this._marker.fire(\"iconchange\", {reason: \"draw\", opts: this.options.params._updated});  // Issue #86\n      }\n\n      if(!this.options.hasOwnProperty(\"html\")) {\n         const html = this.options.html.cloneNode(true);\n         html.container = this.options.html.container;\n         this.options.updater.call(html, this.options.params);\n         if(html.container !== undefined) this.options.html = html.container?html.innerHTML:html.outerHTML;\n         this.options.params.reset();\n      }\n\n      const div = L.DivIcon.prototype.createIcon.call(this, arguments);\n      // Issue #5\n      const filter = this._marker.options.filter;\n      if(filter && this._marker.filtered && !filter.hideable) {\n         filter.transform.call(div, true);\n      }\n      // Fin issue #5\n      return div\n   },\n   /**\n    * Refresca el icono, en caso de que hayan cambiado las opciones de dibujo.\n    * El método modifica directamente el HTML sobre el documento.\n    * @memberof Icon.prototype\n    *\n    * @return {Boolean} ``true`` si se redibujó realmente el icono.\n    */\n   refresh: function() {\n      if(!this.options.params || this.options.params.updated) return false;\n      this.options.updater.call(this._marker.getElement(), this.options.params.modified);\n      this._marker.fire(\"iconchange\", {reason: \"redraw\", opts: this.options.params._updated});  // Issue #86\n      this.options.params.reset();\n\n      // Si se cambia el icono dibujado, el options.html guardado ya no vale.\n      delete this.options.html;\n      return true;\n   },\n});\n","import {equals, getProperty} from \"./utils/index.js\";\nimport CorrSys from \"./corrsys/index.js\";\nimport FilterSys from \"./filtersys.js\";\n\n// Issue #67\n/**\n * Devuelve un array con todas las correcciones aplicadas de modo que\n * cada elemento es un objeto que contiene el nombre de la corrección,\n * las opciones con las que se aplicó y si se hizo manual o automáticamente.\n *\n * @param {String} name  Nombre de una corrección aplicada manualmente. Si\n * se proporciona se devuelve esta misma corrección y todas las que desencadenó\n * automáticamente. Si no se proprociona, se devielven todas las correcciones\n * manuales y automáticas.\n */\nfunction getCorrs(name) {\n   const corr = this.prototype.options.corr;\n\n   if(name) name = [name];\n   else name = Object.keys(corr.getAppliedCorrections());\n\n   const ret = [];\n   for(const n of name) {\n      const opts = corr.getAutoCorrs(n),\n            auto2 = corr.getOptions(n).auto;\n      for(const x in opts) {\n         ret.push({\n            name: x,\n            opts: opts[x],\n            auto: x === n?false:auto2\n         })\n      }\n   }\n   // Ordenamos por nombre de corrección y para una misma\n   // corrección, colocamos primero la manual.\n   return ret.sort((a,b) => -1*(b.name + Number(b.auto) > a.name + Number(a.auto)));\n}\n// Fin issue #67\n\n\n/**\n * Opciones para :js:class:`MutableMarker`. A las generales que permite `L.Marker\n * <https://leafletjs.com/reference-1.4.0.html#marker>`_ de Leaflet\n * añade algunas más\n * @name Marker.prototype.options\n * @type {Marker.Options}\n */\n\n/**\n * Optiones adicionales de la clase :js:class:`Marker`.\n * @typedef {Object} Marker~Options\n * @property {String} opts.mutable  Nombre de la propiedad a la que se conectan los datos de\n * las marcas. Si es una propiedad anidada puede usarse la notación de punto.\n * Por ejemplo, ``feature.properties``.\n * @property {(L.LayerGroup|String|Function)} opts.filter Habilita un :class:`sistema de filtros\n * <CorrSys>` para la clase de marca. Puede adoptar tres valores distintos:\n *    \n * * La capa a la que se agregan las marcas de esta clase. En este caso, el efecto\n *   del filtro será eliminar del mapa las marcas filtradas.\n * * Un nombre que se tomara como el nombre de la clase CSS a la que se quiere que\n *   pertenezcan las marcas filtradas.\n * * Una función de transformación que se aplicará al elemento HTML que\n *   representa en el mapa cada marca filtrada. El contexto de esta función será el propio\n *   elemento HTML.\n */\n\n/**\n * @name L.MutableMarker\n * @extends L.Marker\n * @classdesc  Extiende la clase `L.Marker <https://leafletjs.com/reference-1.4.0.html#marker>`_\n * a fin de permitir que los iconos sean variables y mutables a partir de los datos definidos.\n * Consulte cuáles son las :attr:`Marker#options` opciones que lo habiliten}.\n * @class\n * @hideconstructor\n *\n * @example\n *\n * const Marker = L.MutableMarker.extend({\n *    options: {\n *       mutable: \"feature.properties\",\n *       filter: L.utils.grayFilter\n *    }\n * });\n *\n * const marca = new Marker([37.07,-5.98], {icon: new Icon()});\n */\nexport default L.Marker.extend({\n   /** @lends L.MutableMarker.prototype */\n   statics: {\n      /** @lends L.MutableMarker */\n      extend: function() {\n         const MutableMarker = L.Marker.extend.apply(this, arguments),\n               options = MutableMarker.prototype.options;\n\n         if(!options.mutable) throw new Error(\"La opción 'mutable' es obligatoria\");\n\n         Object.assign(MutableMarker, L.Evented.prototype); // Issue #54\n         options.corr = new CorrSys();\n         /**\n          * Almacena todas las marcas creadas de este tipo\n          * @type {Array.<L.MutableMarker>}\n          */\n         Object.defineProperty(MutableMarker, \"store\", {\n            value: [],\n            configurable: false,\n            enumerable: false,\n            writable: false\n         });\n\n         // Issue #5\n         if(options.filter) options.filter = new FilterSys(options.filter);\n         Object.defineProperty(MutableMarker.prototype, \"filtered\", {\n            get: function() { \n               if(!this.options.filter) throw new Error(\"No se ha definido filtro. ¿Se ha olvidado de incluir la opción filter al crear la clase de marca?\");\n               return this._filtered.length > 0; \n            }\n         });\n         // Fin issue #5\n\n         return MutableMarker;\n      },\n      /**\n       * Vacía :js:attr:`L.MutableMarker.store` de marcas y marca como desaplicadas las correcciones.\n       * @param {Boolean} deep  Si ``true``, también desaplica los filtros.\n       */\n      reset: function(deep) { \n         this.store.length = 0;\n         const corrs = getCorrs.call(this);    // Issue #67\n         this.prototype.options.corr.reset();  // Issue #33\n         // Issue #67\n         for(const c of corrs) {\n            this.fire(\"uncorrect:*\", c);\n            this.fire(`uncorrect:${c.name}`, c);\n         }\n         // Fin issue #67\n         if(deep) {\n            const filters = this.getFilterStatus();  // Issue #67\n            this.prototype.options.filter.reset();  // Issue #40\n            // Issue #67\n            for(const name in filters) {\n               this.fire(\"unfilter:*\", {name: name, opts: filters[name]});\n               this.fire(`unfilter:${name}`, {name: name, opts: filters[name]});\n            }\n            // Fin issue #67\n         }\n      },\n      /**\n       * Elimina una marca del almacén donde se guardan\n       * todos los objetos marca de una misma clase.\n       *\n       * @param {Marker} marker  La marca que se desea eliminar.\n       * @returns {Boolean}  El éxito en la eliminación.\n       */\n      remove: function(marker) {\n         const idx = this.store.indexOf(marker);\n         if(idx === -1) return false;\n         this.store.splice(idx, 1);\n         return true;\n      },\n      /**\n       * Ejecuta un método para todas las marcas almacenadas en store.\n       * Si se proporciona una función progress, entonces la ejecución se interrumpe\n       * cada 200ms, durante 50ms a fin de que no sienta el usuario bloqueda la interfaz.\n       * Además esa función permite conocer dibujar el progreso (por ejemplo, mediante barra).\n       *\n       * @param {String} method  Nombre del métodoo\n       * @param {Function} progress Función que dibuja el progreso de la opración. Recibe\n       * \tcomo argumentos, el ordinal de la operación, el total de operaciones y el tiempo\n       * \tque lkleva ejecutámndose el invoque.\n       * @param {...*} param Parámetros que se pasan al método\n       */\n      invoke: function (method, progress) {\n         const args = Array.prototype.slice.call(arguments, 2);\n         if(!progress) {\n            for(const marker of this.store) {\n               this.prototype[method].apply(marker, args);\n            }\n            return;\n         }\n\n         // Issue #90\n         const started = (new Date()).getTime(),\n               total = this.store.length,\n               noprogress = 1000,  // Para menos de 1 segundo, no se muestra nada.\n               check = 150,     // Cada 150 marcas que comprueba si se hace la suspensión.\n               interval = 200,  // Tiempo de ejecución.\n               delay = 50;      // Tiempo de suspensión de la ejecución.\n         let   i = 0;\n\n         const process = () => {\n            const start = (new Date()).getTime();\n            for(; i<total; i++) {\n               if((i+1)%check === 0) {\n                  const lapso = (new Date()).getTime() - start;\n                  if(lapso > interval) break;\n               }\n               this.prototype[method].apply(this.store[i], args);\n            }\n\n            if(progress !== true) {\n               const lapsoTotal = (new Date()).getTime() - started;\n               if(lapsoTotal > noprogress) progress(i, total, lapsoTotal);\n            }\n            if(i < total) setTimeout(process, delay);\n         }\n\n         process();\n         // Fin issue #90\n      },\n      /**\n       * Registra una corrección en el sistema de correcciones de la marca.\n       * @method Marker.register\n       *\n       * @param {String} name        Nombre que identifica a la corrección.\n       * @param {Object} obj         Objeto que define la corrección\n       * @param {String} obj.attr    Propiedad sobre el que opera la corrección.\n       * Puede usarse la notación de punto para propiedades anidadas.\n       * @param {Function} obj.func  Función que determina si se hace corrección o no.\n       * Cuando la función corrige el array actúa eliminado valores y para\n       * ello se ejecuta repetidamente sobre todos los elementos del *array*. Usa\n       * como contexto la marca a la que pertenece el objeto\n       * que contiene el *array*, y recibe tres parámetros: el primero es\n       * el índice del elemento que se comprueba, el segundo el array mismo\n       * y el tercero un objeto con las opciones aplicables de corrección.\n       * Debe devolver ``true`` (el elemento debe eliminarse) o\n       * ``false`` (no debe hacerlo). La función también puede añadir\n       * nuevos elementos, en vez de eliminar los existentes. Vea la información\n       * sobre el argumento *add* para saber más sobre ello.\n       * @param {Boolean} obj.add    ``true`` si la corrección añade\n       * elementos al array, y cualquier otro valor asimilable a ``false``\n       * si su intención es eliminar elementos. Si los añade, la función deberá\n       * devolver un *array* con los elementos a añadir y sólo se ejecuta una vez,\n       * por lo que su primer argumento (que representa el índice del elemento) vale\n       * ``null``.\n       *\n       * @example\n       * Centro.register(\"adjpue\", {\n       *                   attr: \"adj\",\n       *                   func: function(idx, adj, opts) {\n       *                      return !!(opts.inv ^ (opts.puesto.indexOf(adj[idx].pue) !== -1));\n       *                   },\n       *                })\n       *       .register(\"vt+\", {\n       *                   attr: \"adj\",\n       *                   func: function(idx, adj, opts) {\n       *                      const data = this.getData();\n       *                      //Se deberían obtener las vacantes telefónicas de estos datos...\n       *                      return [\"Interino\", \"Interino\"];\n       *                   },\n       *                   add: true\n       *                });\n       */\n      register: function() {\n         return CorrSys.prototype.register.apply(this.prototype.options.corr, arguments) && this;\n      },\n      // Issue #23\n      /**\n       * Aplica una corrección a las marcas de una clase.\n       * @method Marker.correct\n       *\n       * @params {String} name   Nombre de la corrección.\n       * @params {Object} params Opciones de aplicacion de la corrección.\n       * @params {Boolean} auto  Si ``true``, aplica las correcciones\n       * en cadena, si estas se han definino.\n       *\n       * @example\n       * Centro.correct(\"adjpue\", {puesto: [\"11590107\", \"00590059\"]})\n       */\n      correct: function(name, params, auto) {\n         const corr = this.prototype.options.corr;\n         try {\n            // Si la correción ya está aplicada, sólo no se aplica en\n            // caso de que se aplicara con las mismas opciones.\n            if(equals(corr.getOptions(name).params, params)) return false;\n         }\n         catch(err) {  // La corrección no está registrada.\n            return false;\n         }\n\n         corr.initialize(name, params, auto);\n         for(const marker of this.store) marker.apply(name);\n\n         // Issue #54\n         const corrs = getCorrs.call(this, name);\n         for(const c of corrs) {\n            this.fire(`correct:*`, c);\n            this.fire(`correct:${c.name}`, c);\n         }\n         // Fin issue #54\n         return this;\n      },\n      /**\n       * Elimina una correccón de las marcas de una clase.\n       * @method Marker.uncorrect\n       *\n       * @params {String} name   Nombre de la corrección.\n       * @params {Array.<String>} prev  Si se encadenan correcciones, las\n       * correcciones previas en la cadena. Este parámetro sólo debe usarlo\n       * internamente la libreria.\n       *\n       * @example\n       * marca.uncorrect(\"adjpue\");\n       */\n      uncorrect: function(name) {\n         const corr = this.prototype.options.corr;\n         try {\n            // La corrección no está aplicada.\n            if(!corr.getOptions(name).params) return false;\n         }\n         catch(err) {\n            return false;  // La corrección no está registrada.\n         }\n\n         for(const marker of this.store) marker.unapply(name);\n         // Issue #54\n         const corrs = getCorrs.call(this, name);\n         corr.setParams(name, null);\n         for(const c of corrs) {\n            this.fire(`uncorrect:*`, c);\n            this.fire(`uncorrect:${c.name}`, c);\n         }\n         // Fin issue #54\n         return this;\n      },\n      // Fin issue #23\n      // Issue #58\n      /**\n       * Comprueba si ya se ha aplicado una corrección con unas determinadas opciones\n       * @param {String} name  El nombre de la corrección.\n       * @param {Object} opts  Las nuevas opciones de aplicación.\n       * @param {String} type  El tipo de comprobación que se quiere hacer: si \"manual\",\n       * sólo se pretende comprobar si las opciones son equivalentes a la que se aplicaran\n       * con anterioridad manualmente; si \"auto\", si la aplicación manual ya la incluyen\n       * aplicaciones automáticas anteriores de la corrección. Cualquier otro valor prueba\n       * con la manual y las automáticas.\n       */\n      appliedCorrection: function(name, opts, type) {\n         const corr = this.prototype.options.corr;\n         return corr.isApplied(name, opts, type);\n      },\n      // Fin issue #58\n      /**\n       * Devuelve el estado actual de las correcciones aplicadas sobre las marcas\n       * de un tipo.\n       * @method Marker.getCorrectStatus\n       *\n       * @params {String} name   El nombre de una corrección.\n       *\n       * @returns {Object} Un objeto con dos objetos a su vez. El objeto *manual*, cuyas\n       * claves son los nombres de las correcciones aplicadas manualmente y cuyos valores son\n       * las opciones de corrección; y el objeto *auto* cuyas claves son los nombres de\n       * las correcciones que se han aplicado automáticamente y cuyo valor es un objeto\n       * en que las claves son los nombres de la correcciones que al aplicarse\n       * manualmente la desencadenaron y cuyos valores son las opciones de aplicación\n       * de la corrección automática.\n       */\n      getCorrectStatus: function(name) {\n         const corr = this.prototype.options.corr,\n               ret = {\n                  manual: {},\n                  auto: {}\n               }\n\n         let corrs = corr.getAppliedCorrections();\n         for(const name in corrs) ret.manual[name] = corrs[name];\n\n         for(const name in corr.getCorrections()) {\n            const auto = corr.getAutoParams(name);\n            if(Object.keys(auto).length>0) ret.auto[name] = auto;\n         }\n         return ret;\n      },\n      // Issue #5\n      /**\n       * Registra para una clase de marcas un filtro.\n       * @method Marker.registerF\n       *\n       * @param {String}         name  Nombre del filtro.\n       * @param {Array.<String>}  attrs Nombre de las propiedades de los datos\n       * cuyos valores afectan al filtro.\n       * @param {Function}       func  Función que filtra. Debe devolver\n       * ``true`` (sí filtra) o ``false``.\n       */\n      registerF: function() {\n         const filter = this.prototype.options.filter;\n         if(!filter) throw new Error(\"No se ha definido filtro. ¿Se ha olvidado de incluir la opción filter al crear la clase de marca?\");\n\n         return FilterSys.prototype.register.apply(this.prototype.options.filter, arguments) && this;\n      },\n      /**\n       * Habilita un filtro para las marcas de una clase\n       * @method Marker.filter\n       *\n       * @param {string} name    Nombre del filtro.\n       * @param {Object} params  Opciones para el filtrado.\n       */\n      filter: function(name, params) {\n         const filter = this.prototype.options.filter;\n         if(!filter) throw new Error(\"No se ha definido filtro. ¿Se ha olvidado de incluir la opción filter al crear la clase de marca?\");\n\n         // El filtro no existe o ya estaba habilitado con los mismo parámetros.\n         if(!filter.setParams(name, params, true)) return false;\n         for(const marker of this.store) marker.applyF(name);\n\n         this.fire(\"filter:*\", {name: name, opts: params});  // Issue #54\n         this.fire(`filter:${name}`, {name: name, opts: params});  // Issue #54\n         \n         return this;\n      },\n      /**\n       * Deshabilita un filtro para las marcas de una clase\n       * @method Marker.unfilter\n       *\n       * @param {string} name    Nombre del filtro.\n       */\n      unfilter: function(name) {\n         const filter = this.prototype.options.filter;\n         if(!filter) throw new Error(\"No se ha definido filtro. ¿Se ha olvidado de incluir la opción filter al crear la clase de marca?\");\n\n         const params = filter.getParams(name);  // Issue #54\n\n         if(!filter.disable(name)) return false;  // El filtro no existe o está deshabilitado.\n         for(const marker of this.store) marker.unapplyF(name);\n\n         // #Issue #54\n         this.fire(\"unfilter:*\", {name: name, opts: params});  // Issue #54\n         this.fire(`unfilter:${name}`, {name: name, opts: params});  // Issue #54\n         // Fin #issue 54\n\n         return this;\n      },\n      /**\n       * Cambia el estilo de filtro.\n       * @method Marker.setFilter\n       *\n       * @param {Function|String|L.LayerGroup}  style     Estilo del filtro.\n       * Consulte los valores posibles de la opción :attr:`filter <Marker#options>` para\n       * saber qué valor de estilo suministrar.\n       */\n      setFilterStyle: function(style) {\n         const filter = this.prototype.options.filter;\n         if(!filter) throw new Error(\"No se ha definido filtro. ¿Se ha olvidado de incluir la opción filter al crear la clase de marca?\");\n\n         filter.setStyle(style, this);\n      },\n      /**\n       * Comprueba si ls marcas tienen aplicado un filtro.\n       * @method Marker.hasFilter\n       *\n       * @param {String} name    Nombre del filtro.\n       *\n       * @return {Boolean}\n       */\n      hasFilter: function(name) {\n         const filter = this.prototype.options.filter;\n         if(!filter) throw new Error(\"No se ha definido filtro. ¿Se ha olvidado de incluir la opción filter al crear la clase de marca?\");\n\n         return filter.getFilters().indexOf(name) !== -1\n      },\n      /**\n       * Devuelve el estado actual de los filtros aplicados sobre las marcas del tipo\n       * @method Marker.getFilterStatus\n       *\n       * @param {String} name  Nombre de filtro. Si se especifica uno, sólo se devuelven\n       * las opciones de aplicación de ese filtro en concreto.\n       *\n       * @returns {Object} Un objeto en que las claves son los nombres de los filtros y\n       * los correspondientes valores sus opciones de aplicación; o bien, si se proporcionó\n       * un nombre de filtro, las opciones de aplicación de ese filtro.\n       */\n      getFilterStatus: function(name) {\n         const filter = this.prototype.options.filter;\n         if(!filter) throw new Error(\"No se ha definido filtro. ¿Se ha olvidado de incluir la opción filter al crear la clase de marca?\");\n\n         if(name) return filter.getParams(name);\n\n         const ret = {};\n         for(const name of filter.getFilters()) {\n            ret[name] =  filter.getParams(name);\n         }\n         return ret;\n      }\n      // Fin issue #5\n   },\n   /**\n    * Informa de si la marca se encuentra en el ``store``\n    * del tipo de marca con la que se creó.\n    */\n   _belongsTo: function() {\n      const store = Object.getPrototypeOf(this).constructor.store;\n      return store.indexOf(this) !== -1;\n   },\n   /**\n    * Refresca el dibujo de la marca.\n    *\n    * @param {L.LayerGroup} force   Capa a la que se añade la marca\n    * a la fuerza. Esto es útil cuando se pasa de un estilo de filtro\n    * en que las marcas filtradas se ocultan a otro en que no se hace,\n    * ya la ocultación se implementa expulsando la marca de la capa.\n    * Véase :meth:`FilterSys.setStyle`.\n    */\n   refresh: function(force) {\n      let div = this.getElement();\n      // Issue #5\n      const filter = this.options.filter;\n      if(filter) {\n         if(filter.hideable) {\n            if(this.filtered) {\n               // Si la capa es MarkerClusterGroup. la marca puede estar\n     // en la capa, aunque no se esté en el mapa.\n               filter.transform.removeLayer(this);\n               div = undefined;\n            }\n            else {\n               // Debe comprobarse si la marca sigue estando\n               // en el ``store``, para evitar que el refresco añada\n               // a la capa una marca que ya se desechó con un .reset().\n               if(!div && this._belongsTo()) {\n                  filter.transform.addLayer(this);\n                  div = this.getElement();\n               }\n            }\n         }\n         else {\n            if(div) filter.transform.call(div, this.filtered);\n            else if(force && this._belongsTo()) {\n               force.addLayer(this);\n               div = this.getElement();\n            }\n         }\n      }\n      // Fin issue #5\n      if(!div) return false;  // La marca no está en el mapa.\n      this.options.icon.refresh();\n   },\n   /**\n    * Wrapper para el método homónimo original. Se encarga de\n    * convertir en un descriptor de acceso la propiedad a la que\n    * se conectan los datos, de almacenar en :attr:`Marker.store`\n    * la nueva marca, y de algunos aspectos menores más.\n    */\n   initialize: function() {\n      L.Marker.prototype.initialize.apply(this, arguments);\n      this.constructor.store.push(this);\n      if(this.options.icon) this.options.icon._marker = this;\n      // Issue #22\n      const firstDot = this.options.mutable.indexOf(\".\");\n      const feature = firstDot === -1?this.options.mutable:\n                                      this.options.mutable.substring(0, firstDot);\n      Object.defineProperty(this, \"_\" + feature, {\n         value: undefined,\n         writable: true,\n         configurable: false,\n         enumerable: false\n      });\n\n      Object.defineProperty(this, feature, {\n         get: function() { return this[\"_\" + feature]; },\n         set: function(value) {\n            this[\"_\" + feature] = value;\n            // Creamos este tipo de evento que se lanza\n            // al asociar la marca a los datos.\n            this.fire(\"dataset\");\n         },\n         configurable: false,\n         enumerable: false\n      });\n\n      // Se pasan los arrays de los datos a correctables\n      // y se aplican a la nueva marca filtros y correcciones aplicados.\n      this.on(\"dataset\", function(e) {\n         this._prepare();\n         // Issue #5\n         // Aplicamos a los nuevos datos los filtros ya aplicadas\n         // a los datos de las restantes marcas de la misma clase.\n         const filter = this.options.filter;\n         if(filter) for(const name of filter.getFilters()) this.applyF(name);\n         // Fin issue #5\n         // Y los mismo con las correcciones\n         const corr = this.options.corr;\n         for(const name in corr.getCorrections()) {\n            if(corr.getOptions(name).params) this.apply(name);\n         }\n      });\n      // Fin issue #22\n\n      // Issue #5\n      Object.defineProperty(this, \"_filtered\", {\n         value: [],\n         writable: true,\n         configurable: false,\n         enumerable: false\n      });\n      // Fin Issue #5\n   },\n   /**\n    * Wrapper para el método homónimo original. Se encarga de conectar\n    * la marca al icono.\n    */\n   setIcon: function(icon) {\n      icon._marker = this;\n      L.Marker.prototype.setIcon.apply(this, arguments);\n   },\n   /**\n    * Prepara los datos recién conectado a la marca. Es un método interno\n    * del que hace uso, el descriptor de acceso al que se fijan los datos.\n    * @private\n    */\n   _prepare: function() {  // Convierte Arrays en Correctables.\n      const data = this.getData();\n      if(data === undefined) return false;  // La marca no posee los datos.\n      this.options.corr.prepare(data);\n      return true;\n   },\n   /**\n    * Actualiza el icono asociado a la marca con los datos suministrados.\n    * @private\n    * @param {Object] data  Los datos con los que se quiere actualizar el icono.\n    */\n   _updateIcon: function(data) {\n      const icon = this.options.icon;\n      if(icon.options.params) icon.options.params.change(icon.options.converter.run(data));\n   },\n   // Issue #33\n   /**\n    * Modifica arbitrariamente los datos asociados a la marca.\n    * @param {Object} data  Datos que se quieren añadir a los datos preexistentes.\n    *\n    * @return {Object} El resultado de haber realizado la fusión.\n    */\n   changeData: function(data) {\n      const ret = Object.assign(this.getData(), data);\n\n      // Bug #92\n      const filter = this.options.filter,\n            attrs = Object.keys(data);\n\n      if(filter) {\n         // Aplicamos los filtros que pueden verse afectados\n         // por el cambio, o sea aquellos que dependen de alguno\n         // de los datos que han cambiado.\n         for(const name of filter.getFilters()) {\n            let depends = false;\n            for(const x of filter[name].prop.depends) {\n               if(attrs.indexOf(x) !== -1) {\n                  depends = true;\n                  break\n               }\n            }\n            if(depends) this.applyF(name);\n         }\n      }\n      // Fin bug #92.\n\n      this._updateIcon(data);\n      return ret;\n   },\n   // Fin issue #33\n   /**\n    * Devuelve los datos asociados a la marca.\n    */\n   getData: function() {  // Devuelve los datos asociados a la marca.\n      return getProperty(this, this.options.mutable);\n   },\n   /**\n    *  Aplica una corrección a la marca. No debería usarse directamente, \n    *  ya que las correcciones deben aplicarse a través de {@link Marker.correct}.\n    *  @private\n    *\n    *  @param {String} name   Nombre de la corrección\n    */\n   apply: function(name) {\n      const corr     = this.options.corr,\n            opts     = corr.getOptions(name),\n            params   = opts.params;\n      let   arr, ret;\n      \n      // La resolución de issue #22, hace que esto ocurra sólo\n      // si se registra la corrección después de haber añadido la marca.\n      if(!(arr = corr.isCorrectable(opts.attr, this))) {\n         corr._prepare(this.getData(), opts.attr);\n         arr = getProperty(this.getData(), opts.attr).correctable;\n      }\n\n      if(ret = arr.apply(this, name)) {\n         // Issue #5\n         const filter = this.options.filter;\n         if(filter) for(const f of filter.getFilters(opts.attr)) this.applyF(f);\n         // Fin issue #5\n\n         this._updateIcon({[opts.attr]: getProperty(this.getData(), opts.attr)});\n      }\n\n      // Issue #37\n      if(!opts.auto) return ret;\n      for(const chain of opts.chain) {\n         const newname = name + \" \" + chain.corr,\n               opts = corr.getOptions(newname);\n         // Es la primera vez que se aplica la corrección\n         // sobre alguna de las marcas, por lo que no están calculados los parámetros\n         if(opts.params === undefined) {\n            if(opts.add) {\n               console.warn(`${corr}: No puede ser el eslabón de una cadena porque es una corrección adictiva`);\n               opts.params = corr.setParams(newname, false);\n            }\n            if(corr.looped(name, chain.corr)) {\n               console.debug(`${corr}: Corrección ya aplicada en la cadena de correciones. Se salta para evitar refencias circulares.`);\n               opts.params = corr.setParams(newname, false);\n            }\n            const markerClass = Object.getPrototypeOf(this).constructor;\n            opts.params = corr.setParams(newname, chain.func.call(markerClass, params));\n         }\n\n         if(opts.params !== false) ret = this.apply(newname) || ret;\n      }\n      // Fin issue #37\n\n      return ret;\n   },\n   /**\n    * Elimina una corrección de la marca. No debería usarse directamente, \n    * ya que las correcciones deben eliminarse a través de :meth:`Marker#uncorrect`.\n    * @private\n    *\n    * @param {String} name    Nombre de la corrección.\n    */\n   unapply: function(name) {  // Elimina la corrección.\n      const corr     = this.options.corr,\n            opts     = corr.getOptions(name),\n            arr      = getProperty(this.getData(), opts.attr).correctable;\n      let ret;\n\n      if(ret = arr.unapply(name)) {\n         // Issue #5\n         const filter = this.options.filter;\n         if(filter) for(const f of filter.getFilters(opts.attr)) this.applyF(f);\n         // Fin issue #5\n\n         this._updateIcon({[opts.attr]: getProperty(this.getData(), opts.attr)});\n      }\n\n      // Issue #37\n      if(!opts.auto) return ret;\n      for(const chain of opts.chain) {\n         const newname = name + \" \" + chain.corr,\n               opts = corr.getOptions(newname);\n         if(!opts.params) continue;  // No se aplicó.\n         ret = this.unapply(newname) || ret;\n      }\n      // Fin issue #37\n\n      return ret;\n   },\n   // Issue #5\n   /**\n    * Aplica un filtro a la marca. No debería usarse directamente, \n    * ya que los filtros deben aplicarse a través de :meth:`Marker#filter`.\n    * @private\n    *\n    * @param {String} El nombre del filtro.\n    */\n   applyF: function(name) {\n      const filter = this.options.filter;\n      if(!filter) throw new Error(\"No se ha definido filtro. ¿Se ha olvidado de incluir la opción filtro al crear la clase de marca?\");\n      const params = filter.getParams(name),\n            res = filter[name].call(this, params);\n      if(res) {\n         if(this._filtered.indexOf(name) === -1) {\n            this._filtered.push(name) \n            // Issue #56\n            // El evento sólo se produce cuando un centro sin filtrar, se filtra.\n            if (this._filtered.length === 1) {\n               this.fire(\"filtered\", {name: name, opts: params});\n            }\n            // Fin issue #56\n         }\n      }\n      else this.unapplyF(name);\n      return res;\n   },\n   /**\n    * Elimina un filtro de la marca.No debería usarse directamente, \n    * ya que los filtros deben eliminarse a través de :meth:`Marker#unfilter`.\n    * @private\n    *\n    * @param {String} El nombre del filtro.\n    */\n   unapplyF: function(name) {\n      const filter = this.options.filter;\n      if(!filter) throw new Error(\"No se ha definido filtro. ¿Se ha olvidado de incluir la opción filtro al crear la clase de marca?\");\n      const params = filter.getParams(name),\n            idx = this._filtered.indexOf(name);\n      if(idx !== -1) {\n         this._filtered.splice(idx, 1);\n         // Issue #56\n         // El evento sólo se produce cuando un centro filtrado, deja de estarlo\n         if (this._filtered.length === 0) {\n            this.fire(\"unfiltered\", {name: name, opts: params});\n         }\n         // Fin issue #56\n      }\n      return idx !== 1;\n   }\n   // Fin issue #5\n});\n","import {getProperty} from \"./misc.js\";\n\n// Issue #21\n\n/**\n * Calcula la intersección entre dos *arrays*.\n * @function\n *\n * @param {Array} a1  Un ``Array``.\n * @param {Array} a2 El otro ``Array``.\n *\n * @return {Array}  Un array con los elementos que se encuentra en ambos *arrays*.\n */\nconst intersection = (a1, a2) => a1.filter(e => a2.indexOf(e) !== -1);\n\n/**\n * Obtiene los nombres de las propiedades de un objeto,\n * así como los nombres de las propiedades anidadas.\n *\n * Sólo se extraen propiedades de objetos cuyo constructor\n * sea directamente ``Object``; y, opcionalmente, los índices\n * de los arrays.\n *\n * @param {Object}  o     El objeto a inspeccionar.\n * @param {Number}  depth Profundidad hasta la que se desea inspeccionar.\n *                         Para no definir ninguna, use ``null``.\n * @param {Boolean} arr   ``true``, si se desea inspeccionar las propiedades\n *                        que son ``arrays``.\n * @param {String}  attr  Nombre parcial de la propiedad. En principio,\n *                        sólo debería usarse este parámetro en las llamadas\n *                        recursivas que se hacen dentro de la propia función.\n *\n * @example\n *\n * o = {a: 1, arr: [2, 3], b: {c: 4}}\n * getNestedKeys(o)  // [\"a\", \"arr\", \"b\", \"b.c\"]\n * getNestedKeys(o, true)  // [\"a\", \"arr\", \"arr.0\", \"arr.1\", ,\"b\", \"b.c\"]\n *\n */\nfunction getNestedKeys(o, depth, arr, attr) {\n   let res = [],\n       attrs;\n   if(depth === undefined) depth = null;\n   if(attr) res.push(attr);\n   if(o === null || typeof o !== \"object\" || depth !== null && depth < 1) return res;\n   if(o.constructor === Array) {\n      if(arr) attrs = o.keys();\n      else return res;\n   }\n   else attrs = Object.keys(o);\n   if(depth !== null) depth--;\n   for(const p of attrs) res.push.apply(res, getNestedKeys(o[p], depth, arr, attr?attr + \".\" + p:p));\n   return res;\n}\n\n\n/**\n * Cuenta el número de veces que aparece un carácter en una cadena.\n *\n * @param {String}  La cadena donde se realiza la busqueda\n * @param {String}  El carácter que se desea contar (carácter, no subcadena).\n *\n * @returns {Number} El número de ocurrencias.\n */\nfunction countChar(string, ch) {\n   let res = 0;\n   for(const c of string) if(c===ch) res++;\n   return res;\n}\n\n\n/**\n * Construye conversores entre objetos de distinto tipo.\n *\n * @class\n * @param {Array.<String>} params Enumera las nombres de las propiedades que tiene\n * el objeto de destino.\n *\n * @classdesc Permite definir cómo un objeto se obtiene\n * a partir de las propiedades de otro.\n *\n * @example\n *\n *    const converter = L.utils.Converter([\"numadj\", \"tipo\"])\n *                             .define(\"numadj\", \"adj\", a => a.total)\n *                             .define(\"tipo\");\n */\nfunction Converter(params) {\n   /**\n    * Almacena los nombres de cada propiedad del objeto resultante,\n    * de qué propiedades del objeto de partida dependen y cuál es\n    * la función conversora entre estas últimas y la primera.\n    * @type {Array}\n    * @private\n    */\n   this._params = {}\n   for(const p of params) this._params[p] = {\n      enabled: true,\n      depends: [],\n      converter: null\n   }\n   /**\n    * Guarda la profundidad máxima a la que se encuentran las propiedades\n    * del objeto de partida que influyen en las propiedades del objeto\n    * resultado. Su valor calculándolo a partir de las dependencias que\n    * se van declarando para cada propiedad al usar :meth:`L.utils.Converter#define`\n    * @name L.utils.Converter#__depth\n    * @private\n    * @type {Number}\n    *\n    */\n   Object.defineProperty(this, \"__depth\", {\n      value: 1,\n      writable: true,\n      configurable: false,\n      enumerable: false\n   });\n}\n\n\nObject.defineProperties(Converter.prototype, {\n   /**\n    * Deshabilita una propiedad del objeto resultante. Esto significa\n    * que cuando se obre la conversión del objeto, nunca se intentará\n    * obtener el valor de esta propiedad.\n    * @method L.utils.Converter#disable\n    *\n    * @param {string} param  Nombre de la propiedad.\n    *\n    * @returns {L.utils.Converter} El propio objeto.\n    */\n   \"disable\": {\n      value: function(param) {\n         this._params[param].enabled = false;\n         return this;\n      },\n      writable: false,\n      configurable: false\n   },\n   /**\n    * Habilita una propiedad del objeto resultante.\n    * @method L.utils.Converter#enable\n    *\n    * @param {string} param  Nombre de la propiedad.\n    *\n    * @returns {L.utils.Converter} El propio objeto.\n    */\n   \"enable\": {\n      value: function(param) {\n         this._params[param].enabled = true;\n         return this;\n      },\n      writable: false,\n      configurable: false\n   },\n   /**\n    * Las propiedades definidas para el objeto resultante.\n    * @name L.utils.Converter#params\n    * @type Array.<String>\n    */\n   \"params\": {\n      get: function() {\n         return Object.keys(this._params);\n      },\n      configurable: false\n   },\n   /**\n    * Las propiedades habilitadas para el objeto resultante.\n    * @name L.utils.Converter#enabled\n    * @type Array.<String>\n    */\n   \"enabled\": {\n      get: function() {\n         return this.params.filter(p => this._params[p].enabled);\n      },\n      configurable: false\n   },\n   /**\n    * Informa de si todas las propiedades habilitadas tienen definida una conversión\n    * @name L.utils.Converter#defined\n    * @tyoe {Boolean}\n    */\n   \"defined\": {\n      get: function() {\n         return this.params.every(p => !this._params[p].enabled || this.isDefined(p));\n      },\n      configurable: false\n   },\n   /**\n    * Define cómo obtener una propiedad del objeto resultante.\n    * @method L.utils.Converter#define\n    *\n    * @param {String} param     El nombre de la propiedad.\n    * @param {(Array.<String>|String)} properties Los nombres de las propiedades del objeto\n    *       original que contribuyen a formar el valor de la propiedad del objeto\n    *       resultante. Si la propiedad es una sola, puede evitarse el uso del\n    *       *array* y escribir directamente el nombre. Si se omite este argumento,\n    *       se sobreentiende que el nombre de la propiedad en el objeto original\n    *       y el resultante es el mismo.\n    * @param {Function} func    La función conversora. Debe definirse de modo\n    *       que reciba como argumentos los valores de las\n    *       propiedades que se enumeran en ``properties``, conservando el orden.\n    *\n    * @returns {?L.utils.Converter} El propio objeto de conversión o null, si\n    *       la propiedad que se intenta definir, no se registró al crear\n    *       el objeto.\n    */\n   \"define\": {\n      value: function(param, properties, func) {\n         if(!(properties instanceof Array)) properties = [properties || param];\n         if(!this._params.hasOwnProperty(param)) {\n            console.warn(`Opción ${param} inexistente. No se hace ninguna definición`);\n            return null;\n         }\n         this._params[param].depends = properties;\n         this._params[param].converter = func || (x => x);\n         const depth = Math.max(properties.map(p => countChar(p, \".\") + 1));\n         if(depth > this.__depth) this.__depth = depth;\n         return this;\n      },\n      writable: false,\n      configurable: false\n   },\n   /**\n    * Informa de si la propiedad tiene definida la conversión.\n    * @method L.utils.Converter#isDefined\n    *\n    * @param {String} param  El nombre de la propiedad.\n    *\n    * @returns {Boolean}\n    */\n   \"isDefined\": {\n      value: function(param) {\n         return this._params[param].converter !== null;\n      },\n      writable: false,\n      configurable: false\n   },\n   /**\n    * Lleva a cabo la conversión del objeto suministrado. Sólo se\n    * obtienen las propiedades que estén habilitadas y para las que\n    * se pueda realizar la conversión, porque exista toda la\n    * información requerida en el objeto.\n    * @method L.utils.Converter#run\n    *\n    * @param {Object} o El objeto original\n    *\n    * @returns {Object} El objeto resultante.\n    */\n   \"run\": {\n      value: function(o) {\n         const res = {};\n         for(const p of this._getParams(getNestedKeys(o, this.__depth))) {\n            if(!this.isDefined(p)) throw new Error(`${p}: su conversión no está definida`);\n            const converter = this._params[p].converter,\n                  depends = this._params[p].depends;\n            res[p] = converter.apply(null, depends.map(d => getProperty(o, d)));\n         }\n         return res;\n      },\n      writable: false,\n      configurable: false\n   },\n   /**\n    * Devuelve las propiedades habilitadas cuyas dependecias\n    * se encuentran por completo en la lista de propiedades\n    * que se suministra.\n    * @method L.utils.Converter#_getParams \n    * @private\n    *\n    * @param {Array.<String>} properties Lista con nombres de propiedades\n    *\n    * @returns {Boolean}\n    */\n   \"_getParams\": {\n      value: function(properties) {\n         return this.params.filter(p => this._params[p].enabled\n                                     && this._params[p].depends.length == intersection(this._params[p].depends, properties).length);\n      },\n      writable: false,\n      configurable: false\n   }\n});\n\nexport default Converter;\n","import MutableIcon from \"../mutableIcon.js\";\n\n// Issue #5\n/**\n * Pone en escala de grises un icono filtrado o elimina\n * tal escala si ya no lo está.\n *\n * @this El elemento HTML del documento dentro del cual se encuentra\n * definida la marca \n *\n * @param {boolean} filtered  Si el icono está filtrado o no.\n */\nexport function grayFilter(filtered) {\n   if(filtered) this.style.filter = \"grayscale(100%)\";\n   else this.style.removeProperty(\"filter\");\n}\n\n/**\n * Redefine ``iconCreateFunction`` basándose en la definición original de\n * `L.MarkerClusterGroup <https://github.com/Leaflet/Leaflet.markercluster>`_\n * para que el número del clúster sólo cuente los centros no filtrados.\n *\n * @param {L.MarkerCluster} cluster El cluster sobre el que se aplica la función.\n */\nexport function noFilteredIconCluster(cluster) {\n   const childCount = cluster.getChildCount(),\n         noFilteredChildCount = cluster.getAllChildMarkers().filter(e => !e.filtered).length;\n\n   let c = ' marker-cluster-';\n   if (childCount < 10) {\n      c += 'small';\n   } else if (childCount < 100) {\n      c += 'medium';\n   } else {\n      c += 'large';\n   }\n\n   return new L.DivIcon({ html: '<div><span>' + noFilteredChildCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });\n}\n// Fin issue #5\n\n\n// Issue #2\n/**\n * Facilita la construcción de clases de iconos. Cada clase está asociada\n * a un estilo de icono distinto.\n *\n * @param {string} name          Nombre identificativo para la clase de icono.\n * @param {Object} options       Opciones de construcción de la clase.\n * @param {string} options.css   Para un icono creado con CSS, el archivo .css.\n *    que define el aspecto.\n * @param {string|DocumentFragment|Document} options.html  HTML que define la\n * plantilla del icono. Se puede pasar como:\n *    \n * * Una cadena que contenga directamente el código HTML.\n * * Un ``DocumentFragment``, que sería lo que se obtiene como\n *   contenido de un ``<template>``.\n * * Un ``Document``, que sería lo que se obtiene de haber hecho\n *   una petición AJAX y quedarse cn la respuesta XML.\n *\n * @param {string} options.url   Alternativamente a la opción anterior,\n * la URL de un archivo donde está definido el icono (p.e. un SVG).\n *\n * @param {L.utils.Converter} options.converter  Objeto :class:`L.utils.Converter`\n * para la conversión de los datos en opciones de dibujo.\n *    \n * @param {Function} updater  Función que actualiza el aspecto del icono\n *    a partir de los nuevos valores que tengan las opciones de dibujo.\n *    Toma las opciones de dibujo (o una parte de ellas) y modifica el\n *    elemento DIV (o SVG. etc.) del icono para que adquiera un aspecto\n *    adecuado. Debe escribirse teniendo presente que pueden no pasarse todas\n *    las opciones de dibujo, sino sólo las que se modificaron desde\n *    la última vez que se dibujó el icono. Por tanto, debe escribirse la\n *    función para realizar modificaciones sobre el aspecto preexistente\n *    del icono, en vez de escribirse para recrear el icono desde la plantilla\n *\n * @retuns {Icon} La clase de icono que se desea crear.\n *\n * @example\n * function updater(o) {\n *    const content = this.querySelector(\".content\");\n *    if(o.hasOwnProperty(tipo) content.className = \"content \" + o.tipo;\n *    if(o.hasOwnProperty(numadj) content.textContent = o.numadj;\n *    return this;\n * }\n *\n * const Icon = L.utils.createMutableIconClass(\"chupachups\", {\n *    iconSize: [25, 34],\n *    iconAnchor: [12.5, 34],\n *    css: \"styles/chupachups.css\",\n *    html: '<div class=\"content\"><span></span></div><div class=\"arrow\"></div>',\n *    converter: new L.utils.Converter([\"numadj\", \"tipo\"])\n *                          .define(\"numadj\", \"adj\", a => a.total)\n *                          .define(\"tipo\")\n *    updater: updater\n * });\n */\nexport function createMutableIconClass(name, options) {\n\n   const mutable = options.updater && options.converter\n\n   if(options.css) {\n      const link = document.createElement(\"link\");\n      link.rel = \"stylesheet\";\n      link.href = options.css;\n      link.id = \"leafext-css-\" + name;\n      document.querySelector(\"head\").appendChild(link);\n      delete options.css\n   }\n\n   options.className = options.className || name;\n\n   // Además de devolver el icono, lo precargamos en caso\n   // de que hubiera que ir a buscarlo en un fichero externo\n   if(mutable) return MutableIcon.extend({options: options}).onready(() => true);\n   else {\n      console.warn(\"Falta updater o converter: el icono no será mutable\");\n      return L.DivIcon.extend({options: options});\n   }\n   \n}\n// Fin issue #2\n","import {load, getProperty, equals} from \"./misc.js\";\nimport {grayFilter, noFilteredIconCluster, createMutableIconClass} from \"./icons.js\";\nimport Converter from \"./converter.js\"\nimport Options from \"./options.js\"\n\nexport {load, getProperty, equals, createMutableIconClass,\n        grayFilter, noFilteredIconCluster, Converter, Options}\n","/**\n * Realiza peticiones `AJAX\n * <https://developer.mozilla.org/es/docs/Web/Guide/AJAX>`_. Las peticiones\n * serán asíncronas, a menos que no se proporcionen función de *callback* ni\n * *failback*.\n *\n * @param {Object} params Objeto que contiene los parámetros para realizar\n *    la petición.\n * @param {String} params.url URL de la petición.\n * @param {String} params.method  Método HTTP de petición. Por defecto, será\n * ``GET``, si no se envía parámetros y ``POST``, si sí se hace.\n * @param {Object} params.params Parámetros que se envían en la petición\n * @param {Function} params.callback   Función que se ejecutará si la\n * petición tiene éxito. La función tendrá como único argumento el objeto\n * `XMLHttpRequest <https://developer.mozilla.org/es/docs/Web/API/XMLHttpRequest>`_.\n * @param {Function} params.failback   Función que se ejecutará cuando\n * la petición falle. También admite como argumento un objeto\n * ``XMLHttpRequest``.\n * @param {Object} params.context Objeto que usará como contexto las funciones\n * de *callback* y *failback*.\n *\n * @example\n *\n * load({\n *    url: 'image/centro.svg',\n *    callback: function(xhr) { console.log(\"Éxito\"); },\n *    failback: function(xhr) { console.log(\"Error\"); },\n * });\n *\n */\nexport function load(params) {\n   const xhr = new XMLHttpRequest();\n   let qs = '', \n       method = (params.method || (params.params?\"POST\":\"GET\")).toUpperCase(),\n       contentType = params.contentType ||  \"application/x-www-form-urlencoded\";\n\n   if(params.params) {\n      if(method === \"GET\" || params.contentType === \"application/x-www-form-urlencoded\") {\n         qs = Object.keys(params.params).map(k => k + \"=\" + encodeURIComponent(params.params[k])).join('&');\n      }\n      else if(params.contentType.indexOf(\"application/json\") !== -1) {\n         qs = JSON.stringify(params.params);\n      }\n      else throw new Error(`${params.contentType}: Tipo de contenido no soportando`);\n\n      if(method === \"GET\") {\n         params.url = params.url + \"?\" + qs;\n         qs = \"\";\n      }\n   }\n\n   xhr.open(method, params.url, !!params.callback);\n   for(const header in params.headers || {}) {\n      xhr.setRequestHeader(header, params.headers[header]);\n   }\n   if(method === \"POST\") xhr.setRequestHeader(\"Content-Type\", params.contentType);\n\n   if(params.callback || params.failback) {\n      xhr.onreadystatechange = function() {\n          if(xhr.readyState === 4) {\n            if (xhr.status === 200) {\n               if(params.callback) {\n                  if(params.context) params.callback.call(params.context, xhr);\n                  else params.callback(xhr);\n               }\n            }\n            else if(params.failback) {\n               if(params.context) params.failback.call(params.context, xhr);\n               else params.failback(xhr);\n            }\n          }\n      };\n      if(params.url.endsWith(\".html\")) { // Permite para las respuestas HTML, obtener un responseXML\n         xhr.responseType = \"document\";\n      }\n   }\n\n   xhr.send(qs);\n\n   // Sólo es útil cuando la petición es síncrona.\n   return xhr;\n}\n\n/**\n * Devuelve el valor de la propiedad \"anidada\" de un objeto,\n * aunque comprueba que la no propiedad no sea realmente anidada.\n * @function\n *\n * @param {Object}  obj  El objeto del que se busca la propiedad.\n * @param {String}  name El nombre de la propiedad anidada.\n *\n * @example\n *\n * o = {a:1, b: {c:2, d:3}}\n * geProperty(o, \"b.c\") === o.b.c  // true\n * o = {a:1, \"b.c\": 2, \"b.d\": 3}\n * geProperty(o, \"b.c\") === o[\"b.c\"]  // true\n */\nexport function getProperty(obj, name) {\n   return obj.hasOwnProperty(name)?obj[name]\n                                  :name.split(\".\").reduce((o, k) => o && o.hasOwnProperty(k)?o[k]:undefined, obj);\n}\n\n/**\n * Comprueba si dos objetos son iguales a efectos de lo requerido\n * en este código.\n *\n * @param {Object} o  Un objeto.\n * @param {Object} p  El otro.\n *\n * @returns {Boolean}\n */\nexport function equals(o,p) {\n   if(typeof o !== typeof p) return false;\n   if(typeof o !== \"object\" || o === null) return o == p;  // Comparación laxa.\n\n   const oprop = Object.getOwnPropertyNames(o);\n   const pprop = Object.getOwnPropertyNames(p);\n\n   if(oprop.length !== pprop.length) return false;\n\n   for(let i=0; i<oprop.length; i++) {\n      const name = oprop[i];\n      if(!equals(o[name], p[name])) return false;\n   }\n   return true;\n}\n","/**\n * Construye el objeto modificable. Una vez construido, pueden modificarse los\n * valores de los atributos; pero no añadir nuevos o eliminar alguno de los\n * existentes.\n * @name Options\n * @class\n *\n * @param {Object} Objeto que contiene las propiedades y sus valores iniciales.\n *\n * @classdesc Clase que permite saber si el objeto ha cambiado algunos de\n * sus propiedades desde la última vez que se reseteó (con el método \n * :meth:`Options#reset`).\n *\n * @example\n *\n * const o = new Options({a: 1, b: 2, c: 3});\n * o.updated  // false, ya que se fijaron valores nuevos.\n * o.a = 0    // Fijamos un valor para a\n * o.d = 7    // No tiene efecto. Con strict provocará un error.\n * o.modified // {a: 1}. Sólo devuelve los valores actualizados.\n * o.reset()\n * o.updated  // true. Resetear marca el objeto como actualizado.\n *\n */\n\n/**\n * Nombres prohibidos para las propiedades\n * @private\n * @type {Array.<String>}\n */\nconst banned = [\"updated\"];\n\nfunction Options(opts) {\n   Object.defineProperty(this, \"_updated\", {\n      value: new Set(Object.keys(opts)),\n      writable: true,\n      enumerable: false,\n      configurable: false\n   });\n\n   for(const attr in opts) {\n      if(banned.indexOf(attr) !== -1) throw new Error(attr + \": opción prohibida\");\n      defineOption.call(this, attr);\n      if(opts[attr] !== undefined) this[attr] = opts[attr];\n   }\n   Object.seal(this);\n}\n\n/**\n * Setter para las propiedades. Básicamente se encarga\n * de fijar el valor y apuntar en la propiedad como actualizada.\n * @memberof Options\n * @private\n *\n * @param {String} attr Nombre de la propiedad.\n * @param {*} value  Valor de la propiedad.\n */\nfunction setter(attr, value) {\n   if(this[\"_\" + attr] === value) return;\n   this[\"_\" + attr] = value;\n   this._updated.add(attr);\n}\n\nfunction getter(attr) {\n   return this[\"_\" + attr];\n}\n\n// Define la propiedad que representa una opción.\nfunction defineOption(name) {\n   Object.defineProperty(this, \"_\" + name, {\n      value: undefined,\n      writable: true,\n      configurable: false,\n      enumerable: false\n   });\n   Object.defineProperty(this, name, {\n      get: () => getter.call(this, name),\n      set: (value) => setter.call(this, name, value),\n      configurable: false,\n      enumerable: true\n   });\n}\n\n/**\n * Cambia varios valores a la vez.\n * @method Options#change\n *\n * @param {Obj} obj  Objeto que contien los nombres y los nuevos valores\n *    de las propiedades.\n */\nObject.defineProperty(Options.prototype, \"change\", {\n   value: function(obj) {\n      for(const name in obj) {\n         if(Object.keys(this).indexOf(name) === -1) continue;\n         this[name] = obj[name];\n      }\n   },\n   writable: false,\n   configurable: false,\n   enumerable: false\n});\n\n/**\n * Informa de si se han modificado las opciones. Cuando una opción cambia,\n * se modifica automáticamente el valor de esta propiedad a verdadera.\n * @name Options#updated\n * @type {Boolean}\n */\nObject.defineProperty(Options.prototype, \"updated\", {\n   get: function() { return this._updated.size === 0; },\n   enumerable: false,\n   configurable: false\n});\n\n/**\n * Marca las opciones como actualizadas.\n * @method Options#reset\n */\nObject.defineProperty(Options.prototype, \"reset\", {\n   value: function() { this._updated.clear(); },\n   writable: false,\n   enumerable: false,\n   configurable: false\n})\n\n/**\n * Devuelve sólo las opciones modificadas\n * @name Options#modified\n * @type {Array.<String>}\n */\nObject.defineProperty(Options.prototype, \"modified\", {\n   get: function() {\n      const res = {};\n      this._updated.forEach(e => res[e] = this[e]);\n      return res;\n   },\n   enumerable: false,\n   configurable: false\n});\n\nexport default Options;\n","module.exports = __WEBPACK_EXTERNAL_MODULE_leaflet__;"],"sourceRoot":""}